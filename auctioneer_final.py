#! /usr/bin/env python

import rospy
import random
import sys
from pandas import read_csv

from sequential_single_item_auction.msg import Bids, SetofTasks, RoundResult, NewTasks, ComTasks, SafetyTasks
from strands_executive_msgs.srv import GetGuaranteesForCoSafeTask, GetGuaranteesForCoSafeTaskResponse
from strands_executive_msgs.msg import MdpDomainSpec
from strands_navigation_msgs.msg import TopologicalMap

import csv

class Auctioneer():
    # The central auctioneer used to manage the robots by auctioning tasks (assigned, safety, and hypothetical)
    def __init__(self):
        # Initialise the node
        rospy.init_node("SSIA_auctioneer")

        # Initialise default parameters
        self.finish_cond = False
        self.bid_robot_task_list = []
        self.num_bids = 0
        self.num_robots = 2
        self.num_of_tasks = 2
        self.num_of_new_tasks = 1
        self.num_safety_tasks = 0
        self.num_reply = 0
        self.complete_tasks = []
        self.task_sequence = []
        self.k = 0
        # self.time_publish = 0
        self.time_pub_list = []
        self.task_pub_list = []
        time_interval = 50

        # Initialise the subscriber and publisher used in the auctioneer
        # self.clock_pub = rospy.Publisher("/clock", )
        self.pub_set_of_tasks = rospy.Publisher("/set_of_tasks", SetofTasks, queue_size=1, latch=True)
        self.source_topo = rospy.Subscriber("/topological_map", TopologicalMap, self.top_map_sub)
        self.source_bid = rospy.Subscriber("/bids_and_tasks", Bids, self.check_num_bids)
        self.pub_round_result = rospy.Publisher("/round_result", RoundResult, queue_size=1, latch=True)
        self.pub_new_tasks = rospy.Publisher("/new_tasks",NewTasks,queue_size=1, latch=True)
        self.source_ct = rospy.Subscriber("/com_tasks", ComTasks, self.send_incom_tasks)
        self.pub_safety_tasks = rospy.Publisher("/safety_tasks", SafetyTasks, queue_size=1, latch=True)

        # Wait until the top node is assigned value, the current waypoint.
        self.top_nodes = rospy.wait_for_message("/topological_map", TopologicalMap)
        # while self.top_nodes == []:
        #    rospy.sleep(1)

        # Read the selected csv file to generate initial sequence of tasks and following new tasks
        dataframe = read_csv('exp-tasks-new.csv', usecols=[1], engine='python')
        task_in = dataframe.iloc[:, 0]
        self.task_sequence.append([self.task_to_spec(task) for task in task_in])

        # select whether the safety task is generated by the random process or the author assigned safety task
        self.gen_safety_tasks()
        # self.gen_assigned_safety_task()
        # self.gen_rd_set_of_tasks()
        self.gen_det_set_of_tasks()

        # Initialise the whole generated task sequence
        self.initial_global_tasks = self.my_set_of_tasks.tasks[:]

        # Publish the safety task to each robot if there is any safety task
        if self.my_safety_tasks.tasks != []:
            self.pub_safety_tasks.publish(self.my_safety_tasks)
            # rospy.loginfo("The random generated set of task is : %s", self.my_set_of_tasks.tasks)

        # Publish the initial task sequence if there is any task generated
        if self.my_set_of_tasks.tasks != []:
            self.time_publish = rospy.Time.now()
            # print self.time_publish
            for i in range(self.num_of_tasks):
                self.time_pub_list.append(self.time_publish)
                self.task_pub_list.append(self.my_set_of_tasks.tasks[i])
            # print self.time_pub_list
            # print self.task_pub_list
            self.pub_set_of_tasks.publish(self.my_set_of_tasks)
            # rospy.loginfo("The random generated set of task is : %s", self.my_set_of_tasks.tasks)

        # This is used to introduce a new task to the system which follows an exponential distribution
        while not rospy.is_shutdown():  # exponential distribution for each node so we can control the nodes.
            # time_interval=random.expovariate(0.02)
            # into a single state markov model. gaussian process . at each node. GP.
            # Independent appearance of tasks. Approximate the rate of each node. PRISM (NOT entering some waypoints).
            # GLOBAL tasks. for example make robot staying at some waypoint permanently.
            rospy.sleep(time_interval)
            # self.gen_rd_new_tasks()
            self.gen_det_new_tasks()
            self.my_new_tasks.new_flag = True
            self.time_publish = rospy.Time.now()
            # print self.time_publish
            self.time_pub_list.append(self.time_publish)
            # print self.time_pub_list
            self.task_pub_list.append(self.my_new_tasks.tasks[0])
            # print self.task_pub_list

            self.pub_new_tasks.publish(self.my_new_tasks)
            # rospy.loginfo("The new task is : %s", self.my_new_tasks.tasks)

            with open("publish_final_list.csv", 'wb') as resultFile:
                wr = csv.writer(resultFile, dialect='excel')
                wr.writerow(self.time_pub_list)
                wr.writerow(self.task_pub_list)
        # rospy.spin()

    # Transfer the input csv to LTL
    def task_to_spec(self,task):
        return 'F ("WayPoint' + task[4:] + '")'

    # Detect all topological nodes
    def top_map_sub(self, msg):
        self.top_nodes = [node.name for node in msg.nodes]

    # Check whether the bids from all robots are infinity or not.
    def check_inf_bids(self):
        self.not_all_inf_flag = False
        for i in range(len(self.bid_robot_task_list)):
            # print(self.bid_robot_task_list[i][0])
            if self.bid_robot_task_list[i][0] < sys.maxint:
                self.not_all_inf_flag = True

    # Whenever the auctioneer receives a new bid, it checks whether the number is equal to the number of robots
    def check_num_bids(self, msg):  # update the finish_cond for checking whether robots have done the tasks or not.
        self.num_bids += 1
        self.bid_robot_task_list.append((msg.bid, msg.robot_id, msg.task))  # Create a list of tuples
        # rospy.loginfo("bids received is %s, robot is %s, task is %s", msg.bid, msg.robot_id, msg.task)
        if self.num_bids == self.num_robots:
            # check infinity bids
            # self.check_inf_bids()
            self.not_all_inf_flag = True
            self.auction_step()
            self.finish_cond = True

    def gen_non_round_result(self):
        self.my_round_result = RoundResult()
        self.my_round_result.robot_id = "-1"  # which means this task is not actually allocated to anyone of the robot,
        # however we need to take care about the case when it receives complete set of tasks
        # because it will not be completed forever
        self.my_round_result.task = self.task

    # Find the lowest bid and assign corresponding task to that robot
    def auction_step(self):
        index = self.bid_robot_task_list.index(min(self.bid_robot_task_list))
        self.bid = self.bid_robot_task_list[index][0]
        self.robot_id = self.bid_robot_task_list[index][1]
        self.task = self.bid_robot_task_list[index][2]
        self.num_bids = 0
        self.bid_robot_task_list = []
        if self.not_all_inf_flag:
            self.gen_round_result()
        else:
            self.gen_non_round_result()
            if self.task in self.initial_global_tasks:
                self.initial_global_tasks.remove(self.task)  # remove the impossible task from the initial global list
        if self.my_round_result.task in self.my_set_of_tasks.tasks:
            self.my_set_of_tasks.tasks.remove(self.my_round_result.task)
        self.pub_round_result.publish(self.my_round_result)
        # rospy.loginfo("The round result shows the task %s is allocated to the robot %s, and my current set of task is %s"
        #              , self.my_round_result.task, self.my_round_result.robot_id, self.my_set_of_tasks)

    # Generate the round result message
    def gen_round_result(self):
        self.my_round_result = RoundResult()
        self.my_round_result.robot_id = self.robot_id
        self.my_round_result.task = self.task

    # Transfer the waypoint number to an Eventually LTL specification
    def random_wp_spec(self):
        return 'F ("' + random.choice(self.top_nodes) + '")'

    # Transfer the waypoint number to an Always LTL specification
    def random_safety_spec(self):
        return 'G (!"' + random.choice(self.top_nodes) + '")'

    # This is used in dynamical scenario. When the auctioneer receives the complete message from the robot,
    # it sends the incomplete task list to the robot
    def send_incom_tasks(self, msg):
        self.num_reply += 1
        self.complete_tasks += msg.tasks
        # rospy.loginfo("received complete task is %s, and it's from robot %s", msg.tasks, msg.robot_id)
        if self.num_reply == self.num_robots:
            self.num_reply = 0
            self.gen_incomplete_tasks()
            self.my_new_tasks.tasks = self.incomplete_tasks[:]
            self.my_new_tasks.new_flag = False
            self.pub_new_tasks.publish(self.my_new_tasks)
            self.complete_tasks = []

    # This method removes completed tasks from the global task sequence
    def gen_incomplete_tasks(self):
        self.incomplete_tasks = self.initial_global_tasks[:]  # Take care here because robot return list not empty
        for i in range(len(self.complete_tasks)):
            if self.complete_tasks[i] in self.incomplete_tasks:  # This may cause a potential unmatched bug
                self.incomplete_tasks.remove(self.complete_tasks[i])

    # Generate a random set of assigned task which has no repentance
    def gen_rd_set_of_tasks(self):
        self.my_set_of_tasks = SetofTasks()
        while len(self.my_set_of_tasks.tasks) < self.num_of_tasks:
            self.random_waypoint=self.random_wp_spec()
            if self.random_waypoint in self.my_set_of_tasks.tasks:
                self.random_waypoint = self.random_wp_spec()
            else:
                self.my_set_of_tasks.tasks.append(self.random_waypoint)

    # Generate a random new task
    def gen_rd_new_tasks(self):
        self.my_new_tasks = NewTasks()
        while len(self.my_new_tasks.tasks) < self.num_of_new_tasks:
            self.random_waypoint=self.random_wp_spec()
            if self.random_waypoint in self.my_new_tasks.tasks:
                self.random_waypoint = self.random_wp_spec()
            else:
                self.my_new_tasks.tasks.append(self.random_waypoint)
        self.my_set_of_tasks.tasks += self.my_new_tasks.tasks
        self.initial_global_tasks += self.my_new_tasks.tasks

    # Generate a random safety task
    def gen_safety_tasks(self):
        self.my_safety_tasks=SetofTasks()
        while len(self.my_safety_tasks.tasks) < self.num_safety_tasks:
            self.random_waypoint_spec=self.random_safety_spec()
            if self.random_waypoint_spec in self.my_safety_tasks.tasks:
                self.random_waypoint_spec = self.random_safety_spec()
            else:
                self.my_safety_tasks.tasks.append(self.random_waypoint_spec)

    # Generate an artificial safety task
    def gen_assigned_safety_task(self):
        self.my_safety_tasks = SetofTasks()
        self.my_safety_tasks.tasks.append('G (!"WayPoint4")')

    # Generate artificial task sequence which is following the CSV file
    def gen_det_set_of_tasks(self):
        self.my_set_of_tasks = SetofTasks()
        for i in range(self.num_of_tasks):
            self.my_set_of_tasks.tasks.append(self.task_sequence[0][i])

    def gen_det_new_tasks(self):
        self.my_new_tasks = NewTasks()
        self.my_new_tasks.tasks.append(self.task_sequence[0][self.num_of_tasks+self.k])
        self.k += 1
        self.my_set_of_tasks.tasks += self.my_new_tasks.tasks
        self.initial_global_tasks += self.my_new_tasks.tasks


if __name__ == '__main__':
    auctioneer=Auctioneer()
