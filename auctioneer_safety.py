#! /usr/bin/env python

import rospy
import random

from sequential_single_item_auction.msg import Bids, SetofTasks, RoundResult, NewTasks, ComTasks, SafetyTasks
from strands_executive_msgs.srv import GetGuaranteesForCoSafeTask, GetGuaranteesForCoSafeTaskResponse
from strands_executive_msgs.msg import MdpDomainSpec
from strands_navigation_msgs.msg import TopologicalMap


class Auctioneer():
    # set up two publishers(SetofTasks, RoundResult) and one subscriber(Bids)
    def __init__(self):
        rospy.init_node("SSIA_auctioneer")
        self.finish_cond = False
        self.bid_robot_task_list=[]
        self.num_bids=0
        self.num_robots=2
        self.num_of_tasks=2
        self.num_of_new_tasks=1

        self.num_safety_tasks=1

        self.num_reply=0
        self.complete_tasks=[]

        self.pub_set_of_tasks = rospy.Publisher("/set_of_tasks", SetofTasks, queue_size=1)
        self.source_topo=rospy.Subscriber("/topological_map", TopologicalMap, self.top_map_sub)
        self.source_bid = rospy.Subscriber("/bids_and_tasks", Bids, self.check_num_bids)
        self.pub_round_result = rospy.Publisher("/round_result", RoundResult, queue_size=1)
        self.pub_new_tasks = rospy.Publisher("/new_tasks",NewTasks,queue_size=1)

        self.source_ct = rospy.Subscriber("/com_tasks", ComTasks, self.send_incom_tasks)

        self.pub_safety_tasks = rospy.Publisher("/safety_tasks", SafetyTasks, queue_size=1)

        self.top_nodes = []
        while self.top_nodes == []:
            rospy.sleep(1)

        #select whether the safety task is generated by the random process or the author assigned safety task
        #self.gen_safety_tasks()
        self.gen_assigned_safety_task()

        self.gen_rd_set_of_tasks()

        #self.initial_global_tasks=self.my_safety_tasks.tasks[:]+self.my_set_of_tasks.tasks[:]
        self.initial_global_tasks=self.my_set_of_tasks.tasks[:]

        if self.my_safety_tasks.tasks!=[]:
            self.pub_safety_tasks.publish(self.my_safety_tasks)
            rospy.loginfo("The random generated set of task is : %s", self.my_set_of_tasks.tasks)

        if self.my_set_of_tasks.tasks!=[]:
            self.pub_set_of_tasks.publish(self.my_set_of_tasks)
            rospy.loginfo("The random generated set of task is : %s", self.my_set_of_tasks.tasks)

        while not rospy.is_shutdown(): #exponential distribution for each node so we can control the nodes.
            time_interval=random.expovariate(0.01) #into a single state markov model. gaussian process . at each node. GP. Independent appearance of tasks. Approxiate the rate of each node. PRISM (NOT entering some waypoints). GLOBAL tasks. for example make robot staying at some waypoint permanently.
            rospy.sleep(time_interval)
            self.gen_rd_new_tasks()
            self.my_new_tasks.new_flag=True
            self.pub_new_tasks.publish(self.my_new_tasks)
            rospy.loginfo("The new task is : %s", self.my_new_tasks.tasks)

        rospy.spin()

    def top_map_sub(self, msg):
        self.top_nodes = [node.name for node in msg.nodes]

    def check_num_bids(self,msg):            # update the finish_cond for checking whether robots have done the tasks or not.
        robot_temp_list=[]
        # if self.my_set_of_tasks.tasks!=[]:
        self.num_bids+=1
        robot_temp_list.append(msg.robot_id)
        self.bid_robot_task_list.append((msg.bid, msg.robot_id, msg.task))  # Create a list of tuples
        rospy.loginfo("bids received is %s, robot is %s, task is %s", msg.bid, msg.robot_id, msg.task)
        if self.num_bids==self.num_robots:
            self.auction_step()
            self.finish_cond = True
            robot_temp_list=[]

    def auction_step(self):
        index = self.bid_robot_task_list.index(min(self.bid_robot_task_list))
        self.bid = self.bid_robot_task_list[index][0]
        self.robot_id = self.bid_robot_task_list[index][1]
        self.task = self.bid_robot_task_list[index][2]
        self.num_bids=0
        self.bid_robot_task_list=[]
        finish_cond=False
        self.gen_round_result()
        if self.my_round_result.task in self.my_set_of_tasks.tasks:
            self.my_set_of_tasks.tasks.remove(self.my_round_result.task)
        self.pub_round_result.publish(self.my_round_result)
        rospy.loginfo("The round result shows the task %s is allocated to the robot %s, and my current set of task is %s"
                      , self.my_round_result.task, self.my_round_result.robot_id, self.my_set_of_tasks)

    def gen_round_result(self):
        self.my_round_result=RoundResult()
        self.my_round_result.robot_id=self.robot_id
        self.my_round_result.task=self.task

    def gen_rd_set_of_tasks(self):
        self.my_set_of_tasks=SetofTasks()
        while len(self.my_set_of_tasks.tasks) < self.num_of_tasks:
            self.random_waypoint=self.random_wp_spec()
            if self.random_waypoint in self.my_set_of_tasks.tasks:
                self.random_waypoint=self.random_wp_spec()
            else:
                self.my_set_of_tasks.tasks.append(self.random_waypoint)

    def gen_rd_new_tasks(self):
        self.my_new_tasks=NewTasks()
        while len(self.my_new_tasks.tasks) < self.num_of_new_tasks:
            self.random_waypoint=self.random_wp_spec()
            if self.random_waypoint in self.my_new_tasks.tasks:
                self.random_waypoint=self.random_wp_spec()
            else:
                self.my_new_tasks.tasks.append(self.random_waypoint)
        self.my_set_of_tasks.tasks+=self.my_new_tasks.tasks

        self.initial_global_tasks += self.my_new_tasks.tasks

    def random_wp_spec(self):
        return 'F ("' + random.choice(self.top_nodes) + '")'

    def random_safety_spec(self):
        return 'G (!"' + random.choice(self.top_nodes) + '")'
        #G should not be in co-safe LTL?  F (waypoint) X (G(waypoint))

    def send_incom_tasks(self,msg):
        self.num_reply+=1
        self.complete_tasks+=msg.tasks
        rospy.loginfo("received complete task is %s, and it's from robot %s",msg.tasks, msg.robot_id)
        if self.num_reply==self.num_robots:
            self.num_reply=0
            self.gen_incomplete_tasks()
            self.my_new_tasks.tasks=self.incomplete_tasks[:]
            self.my_new_tasks.new_flag=False
            self.pub_new_tasks.publish(self.my_new_tasks)
            self.complete_tasks=[]

    def gen_incomplete_tasks(self):
        self.incomplete_tasks=self.initial_global_tasks[:]
        for i in range(len(self.complete_tasks)):
            self.incomplete_tasks.remove(self.complete_tasks[i])

    def gen_safety_tasks(self):
        self.my_safety_tasks=SetofTasks()
        while len(self.my_safety_tasks.tasks) < self.num_safety_tasks:
            self.random_waypoint_spec=self.random_safety_spec()
            if self.random_waypoint_spec in self.my_safety_tasks.tasks:
                self.random_waypoint_spec=self.random_safety_spec()
            else:
                self.my_safety_tasks.tasks.append(self.random_waypoint_spec)

    def gen_assigned_safety_task(self):
        self.my_safety_tasks=SetofTasks()
        self.my_safety_tasks.tasks.append('G (!"WayPoint4")')
if __name__ == '__main__':
    auctioneer=Auctioneer()
